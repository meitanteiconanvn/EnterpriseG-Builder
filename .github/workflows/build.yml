name: Build EnterpriseG Edition

on:
  workflow_dispatch:
    inputs:
      target_sku:
        description: 'Target SKU'
        required: true
        default: 'EnterpriseG'
        type: choice
        options:
          - 'EnterpriseG'
          - 'EnterpriseS'
          - 'WNC'
          - 'Starter'
      iso_url:
        description: 'Windows ISO URL'
        required: true
        type: string
      iso_output_name:
        description: 'Output filename'
        required: false
        default: 'Windows-EnterpriseG'
        type: string
      wim_index:
        description: 'WIM Index (empty=auto)'
        required: false
        default: ''
        type: string
      msedge:
        description: 'Edge'
        required: false
        default: 'With'
        type: choice
        options:
          - 'With'
          - 'Without'
      defender:
        description: 'Defender'
        required: false
        default: 'With'
        type: choice
        options:
          - 'With'
          - 'Without'
      winre:
        description: 'WinRE'
        required: false
        default: 'With'
        type: choice
        options:
          - 'With'
          - 'Without'
  push:
    branches:
      - master
      - main
  pull_request:
    branches:
      - master
      - main

jobs:
  build:
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Download Windows ISO
      shell: pwsh
      run: |
        Write-Host "Downloading Windows ISO..."
        $isoUrl = "${{ github.event.inputs.iso_url || env.ISO_URL }}"
        if (-not $isoUrl) {
          Write-Error "ISO URL is required. Please provide it via workflow input or environment variable."
          exit 1
        }
        
        $isoPath = "$PWD\source.iso"
        
        Write-Host "Downloading ISO from: $isoUrl"
        Write-Host "Saving to: $isoPath"
        
        try {
          # Optimize download with resume support and better error handling
          $ProgressPreference = 'SilentlyContinue'
          
          # Use BITS (Background Intelligent Transfer Service) for better resume support
          # Check if file exists and resume download
          if (Test-Path $isoPath) {
            Write-Host "Existing file found. Checking if resume is needed..."
            $existingSize = (Get-Item $isoPath).Length
            
            # Try to get file size from server
            try {
              $request = [System.Net.HttpWebRequest]::Create($isoUrl)
              $request.Method = "HEAD"
              $response = $request.GetResponse()
              $contentLength = $response.ContentLength
              $response.Close()
              
              if ($existingSize -lt $contentLength -and $contentLength -gt 0) {
                Write-Host "Resuming download from $existingSize bytes..."
                $request = [System.Net.HttpWebRequest]::Create($isoUrl)
                $request.AddRange($existingSize)
                $response = $request.GetResponse()
                $stream = $response.GetResponseStream()
                $fileStream = [System.IO.File]::OpenWrite($isoPath)
                $fileStream.Seek($existingSize, [System.IO.SeekOrigin]::Begin) | Out-Null
                $buffer = New-Object byte[] 1MB
                $bytesRead = 0
                do {
                  $bytesRead = $stream.Read($buffer, 0, $buffer.Length)
                  $fileStream.Write($buffer, 0, $bytesRead)
                } while ($bytesRead -gt 0)
                $fileStream.Close()
                $stream.Close()
                $response.Close()
                Write-Host "Resume download completed"
              } else {
                Write-Host "File already complete or cannot resume. Starting fresh download..."
                Remove-Item $isoPath -Force
                Invoke-WebRequest -Uri $isoUrl -OutFile $isoPath -UseBasicParsing -TimeoutSec 3600 -MaximumRetryCount 3
              }
            } catch {
              Write-Host "Resume not supported, downloading fresh..."
              Remove-Item $isoPath -Force
              Invoke-WebRequest -Uri $isoUrl -OutFile $isoPath -UseBasicParsing -TimeoutSec 3600 -MaximumRetryCount 3
            }
          } else {
            # Fresh download with optimized settings
            Invoke-WebRequest -Uri $isoUrl -OutFile $isoPath -UseBasicParsing -TimeoutSec 3600 -MaximumRetryCount 3
          }
          
          $isoSize = (Get-Item $isoPath).Length / 1GB
          Write-Host "ISO download completed. File size: $([math]::Round($isoSize, 2)) GB"
        } catch {
          Write-Error "Failed to download ISO: $_"
          exit 1
        }
        
        if (-not (Test-Path $isoPath)) {
          Write-Error "ISO was not downloaded successfully"
          exit 1
        }
      env:
        ISO_URL: ${{ github.event.inputs.iso_url }}
        
    - name: Setup ISO creation tools
      shell: pwsh
      run: |
        Write-Host "Setting up ISO creation tools..."
        
        # Check multiple common locations for oscdimg
        $oscdimgPaths = @(
          "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",
          "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",
          "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\x86\Oscdimg\oscdimg.exe"
        )
        
        $oscdimgFound = $false
        $oscdimgPath = $null
        
        foreach ($path in $oscdimgPaths) {
          if (Test-Path $path) {
            $oscdimgPath = $path
            $oscdimgFound = $true
            Write-Host "Found oscdimg at: $path"
            break
          }
        }
        
        if (-not $oscdimgFound) {
          Write-Host "oscdimg not found. Attempting to download oscdimg..."
          
          # Try downloading oscdimg standalone first (faster than full ADK)
          # Alternative: Use Chocolatey if available
          $chocoAvailable = Get-Command choco -ErrorAction SilentlyContinue
          
          if ($chocoAvailable) {
            Write-Host "Using Chocolatey to install Windows ADK Deployment Tools..."
            try {
              choco install windows-adk-deployment-tools -y --no-progress
              Start-Sleep -Seconds 10 # Wait for installation
              
              # Check again
              foreach ($path in $oscdimgPaths) {
                if (Test-Path $path) {
                  $oscdimgPath = $path
                  $oscdimgFound = $true
                  Write-Host "oscdimg installed via Chocolatey at: $path"
                  break
                }
              }
            } catch {
              Write-Warning "Chocolatey installation failed: $_"
            }
          }
          
          # If still not found, try downloading Windows ADK installer (last resort)
          if (-not $oscdimgFound) {
            Write-Host "Downloading Windows ADK installer (this may take a while)..."
            
            # Download Windows ADK installer (minimal deployment tools)
            $adkUrl = "https://go.microsoft.com/fwlink/?linkid=2249370"
            $adkInstaller = "$PWD\adksetup.exe"
            
            try {
              Write-Host "Downloading Windows ADK installer..."
              Invoke-WebRequest -Uri $adkUrl -OutFile $adkInstaller -UseBasicParsing -TimeoutSec 600
              
              Write-Host "Installing Windows ADK Deployment Tools (silent install, may take 5-10 minutes)..."
              # Install silently with only Deployment Tools component
              $installArgs = "/quiet /norestart /features OptionId.DeploymentTools"
              $process = Start-Process -FilePath $adkInstaller -ArgumentList $installArgs -Wait -PassThru -NoNewWindow
              
              if ($process.ExitCode -eq 0 -or $process.ExitCode -eq 3010) {
                Write-Host "Windows ADK installed successfully"
                
                # Wait a bit for files to be available
                Start-Sleep -Seconds 5
                
                # Check again for oscdimg
                foreach ($path in $oscdimgPaths) {
                  if (Test-Path $path) {
                    $oscdimgPath = $path
                    $oscdimgFound = $true
                    Write-Host "oscdimg now available at: $path"
                    break
                  }
                }
              } else {
                Write-Warning "Windows ADK installation exited with code: $($process.ExitCode)"
              }
              
              # Clean up installer
              Remove-Item $adkInstaller -Force -ErrorAction SilentlyContinue
            } catch {
              Write-Warning "Failed to download/install Windows ADK: $_"
              Write-Host "Will fall back to ZIP archive creation"
            }
          }
        }
        
        # Save oscdimg path to environment variable for later steps
        if ($oscdimgFound) {
          Write-Host "oscdimg_path=$oscdimgPath" | Out-File -FilePath "$env:GITHUB_ENV" -Encoding utf8 -Append
        } else {
          Write-Host "oscdimg_path=" | Out-File -FilePath "$env:GITHUB_ENV" -Encoding utf8 -Append
        }
        
    - name: Extract install.wim from ISO
      shell: pwsh
      run: |
        Write-Host "Extracting install.wim from ISO..."
        
        $isoPath = "$PWD\source.iso"
        $mountPath = "$PWD\iso_mount"
        $sourceWimPath = "$PWD\source_install.wim"
        $wimPath = "$PWD\install.wim"
        $wimIndex = "${{ github.event.inputs.wim_index }}"
        
        # Mount ISO
        Write-Host "Mounting ISO..."
        $mountResult = Mount-DiskImage -ImagePath $isoPath -StorageType ISO -PassThru
        $driveLetter = ($mountResult | Get-Volume).DriveLetter
        
        if (-not $driveLetter) {
          Write-Error "Failed to mount ISO"
          exit 1
        }
        
        Write-Host "ISO mounted to drive: $driveLetter`:"
        
        # Extract install.wim from sources folder
        $sourceWim = "${driveLetter}:\sources\install.wim"
        
        if (-not (Test-Path $sourceWim)) {
          Write-Error "install.wim not found in ISO sources folder"
          Dismount-DiskImage -ImagePath $isoPath
          exit 1
        }
        
        Write-Host "Copying install.wim from ISO..."
        Copy-Item -Path $sourceWim -Destination $sourceWimPath -Force
        
        # Also copy ISO structure for later ISO recreation
        # Optimize robocopy with multi-threading and better performance
        Write-Host "Copying ISO structure..."
        New-Item -ItemType Directory -Path $mountPath -Force | Out-Null
        # Use /MT for multi-threaded copy (8 threads), /NP to disable progress, /NDL/NJH/NJS for minimal logging
        robocopy "${driveLetter}:\" $mountPath /E /XD sources /MT:8 /NP /NDL /NJH /NJS /R:3 /W:5 | Out-Null
        $robocopyExit = $LASTEXITCODE
        # Robocopy returns 0-7 for success, 8+ for errors
        if ($robocopyExit -ge 8) {
          Write-Warning "Robocopy exited with code $robocopyExit. Some files may not have been copied."
        }
        
        # Unmount ISO
        Write-Host "Unmounting ISO..."
        Dismount-DiskImage -ImagePath $isoPath
        
        # Delete source ISO immediately to save space and improve performance
        Write-Host "Deleting source ISO to save disk space..."
        Remove-Item -Path $isoPath -Force -ErrorAction SilentlyContinue
        
        # Verify source install.wim exists
        if (-not (Test-Path $sourceWimPath)) {
          Write-Error "install.wim extraction failed"
          exit 1
        }
        
        $wimSize = (Get-Item $sourceWimPath).Length / 1GB
        Write-Host "install.wim extracted successfully. Size: $([math]::Round($wimSize, 2)) GB"
        
        # Get WIM info to find Professional edition index and build number
        Write-Host "Analyzing WIM file to find Professional edition and build number..."
        $wimlibPath = "$PWD\Files\wimlib-imagex.exe"
        
        $detectedBuildNumber = $null
        
        if (-not (Test-Path $wimlibPath)) {
          Write-Warning "wimlib-imagex.exe not found, using full install.wim"
          Copy-Item -Path $sourceWimPath -Destination $wimPath -Force
        } else {
          # Get WIM info
          $wimInfo = & $wimlibPath info $sourceWimPath 2>&1 | Out-String
          
          Write-Host "WIM Info:"
          Write-Host $wimInfo
          
          # Extract build number from WIM info
          # Format: Version: 10.0.22621.1 or similar
          $lines = $wimInfo -split "`n"
          $currentIndex = 0
          $proIndex = $null
          
          foreach ($line in $lines) {
            # Detect build number from version string
            if ($line -match "Version:\s+10\.0\.(\d+)\.(\d+)") {
              $buildNum = $matches[1]
              if (-not $detectedBuildNumber) {
                $detectedBuildNumber = $buildNum
                Write-Host "Detected Windows Build Number: $detectedBuildNumber"
              }
            }
            
            # Find Professional edition index
            if ($line -match "Index:\s+(\d+)") {
              $currentIndex = [int]$matches[1]
            }
            if ($line -match "Edition ID:\s+Professional" -or $line -match "Name:\s+.*Professional") {
              $proIndex = $currentIndex
              Write-Host "Found Professional edition at index: $proIndex"
            }
          }
          
          # Save build number to file for later steps
          if ($detectedBuildNumber) {
            Set-Content -Path "detected_build_number.txt" -Value $detectedBuildNumber
            Write-Host "Build number saved to detected_build_number.txt"
          }
          
          # Find Professional edition index
          if ([string]::IsNullOrWhiteSpace($wimIndex)) {
            if (-not $proIndex) {
              Write-Warning "Could not auto-detect Professional edition. Trying index 1..."
              $proIndex = 1
            }
          } else {
            $proIndex = [int]$wimIndex
            Write-Host "Using specified WIM index: $proIndex"
          }
          
          Write-Host "Extracting Professional edition (index $proIndex) from WIM..."
          
          # Extract only Professional edition to install.wim
          & $wimlibPath export $sourceWimPath $proIndex $wimPath --compress=none
          
          if (-not (Test-Path $wimPath)) {
            Write-Error "Failed to extract Professional edition from WIM"
            exit 1
          }
          
          $extractedSize = (Get-Item $wimPath).Length / 1GB
          Write-Host "Professional edition extracted successfully. Size: $([math]::Round($extractedSize, 2)) GB"
          
          # Clean up source WIM
          Remove-Item -Path $sourceWimPath -Force -ErrorAction SilentlyContinue
        }
        
        if (-not $detectedBuildNumber) {
          Write-Warning "Could not auto-detect build number from WIM. Using default 22621."
          $detectedBuildNumber = "22621"
          Set-Content -Path "detected_build_number.txt" -Value $detectedBuildNumber
        }
        
    - name: Configure Bedi.ini
      shell: pwsh
      run: |
        # Read detected build number from previous step
        if (Test-Path "detected_build_number.txt") {
          $buildNumber = Get-Content "detected_build_number.txt" -Raw
          $buildNumber = $buildNumber.Trim()
          Write-Host "Using detected build number: $buildNumber"
        } else {
          Write-Warning "Build number file not found. Using default 22621."
          $buildNumber = "22621"
        }
        
        $targetSku = "${{ github.event.inputs.target_sku }}"
        $msedge = "${{ github.event.inputs.msedge }}"
        $defender = "${{ github.event.inputs.defender }}"
        $winre = "${{ github.event.inputs.winre }}"
        
        # Set defaults if not provided (for push/PR events)
        if ([string]::IsNullOrWhiteSpace($targetSku)) { $targetSku = "EnterpriseG" }
        if ([string]::IsNullOrWhiteSpace($msedge)) { $msedge = "With" }
        if ([string]::IsNullOrWhiteSpace($defender)) { $defender = "With" }
        if ([string]::IsNullOrWhiteSpace($winre)) { $winre = "With" }
        
        $configLines = @(
          ";#Bedi v7.44 Configurations",
          "_sourSKU=Professional",
          "_targSKU=$targetSku",
          "_store=With",
          "_defender=$defender",
          "_msedge=$msedge",
          "_helospeech=With",
          "_winre=$winre",
          "_wifirtl=With"
        )
        $config = $configLines -join "`n"
        
        Set-Content -Path "Bedi.ini" -Value $config
        Write-Host "Configuration saved to Bedi.ini"
        Get-Content Bedi.ini
        
    - name: Verify required files
      shell: pwsh
      run: |
        Write-Host "Verifying required files..."
        
        # Check install.wim
        if (-not (Test-Path "install.wim")) {
          Write-Error "install.wim not found in root directory"
          exit 1
        }
        
        # Check required tools
        $requiredFiles = @(
          "Files\wimlib-imagex.exe",
          "Files\7z.exe",
          "Files\NSudo.exe",
          "Files\expand.exe",
          "Files\expand_new.exe",
          "Files\7z.dll",
          "Files\libwim-15.dll",
          "Files\ModLCU.cmd",
          "Files\msdelta.dll",
          "Files\PSFExtractor.exe",
          "Files\upmod.cmd"
        )
        
        foreach ($file in $requiredFiles) {
          if (-not (Test-Path $file)) {
            Write-Error "Required file not found: $file"
            exit 1
          }
        }
        
        Write-Host "All required files verified"
        
    - name: Run EnterpriseG Build
      shell: pwsh
      run: |
        Write-Host "Running EnterpriseG build process..."
        
        # Read detected build number from previous step
        if (Test-Path "detected_build_number.txt") {
          $buildNumber = Get-Content "detected_build_number.txt" -Raw
          $buildNumber = $buildNumber.Trim()
          Write-Host "Build Number: $buildNumber"
        } else {
          Write-Warning "Build number not detected. Using default."
        }
        
        Write-Host "Target SKU: ${{ github.event.inputs.target_sku }}"
        
        # Bedi.cmd will check Bedi.ini and if config matches, it will skip menu
        # If config doesn't match, it will update Bedi.ini and exit, then we need to run again
        # To ensure it works, we need to determine the correct menu option based on target SKU
        
        $targetSku = "${{ github.event.inputs.target_sku }}"
        $menuOption = switch ($targetSku) {
          "EnterpriseG" { "1" }
          "EnterpriseS" { "2" }
          "WNC" { "3" }
          "Starter" { "4" }
          default { "1" }
        }
        
        # Create a wrapper script to automate Bedi.cmd menu selection
        # Bedi.cmd will check Bedi.ini - if config matches menu selection, it skips menu
        # Since we already created Bedi.ini with correct config, Bedi should skip menu
        
        Write-Host "Verifying Bedi.ini configuration..."
        $configContent = Get-Content "Bedi.ini" -Raw
        if ($configContent -match "_targSKU=$targetSku" -and $configContent -match "_sourSKU=Professional") {
            Write-Host "Bedi.ini configuration is correct, Bedi.cmd should skip menu"
        } else {
            Write-Warning "Bedi.ini configuration may not match. Bedi will update it if needed."
        }
        
        Write-Host "Starting Bedi.cmd in non-interactive mode..."
        Write-Host ""
        
        # Determine menu option based on target SKU
        # Menu options: 1=EnterpriseG, 2=EnterpriseS, 3=WNC, 4=Starter
        $menuOption = switch ($targetSku) {
            "EnterpriseG" { "1" }
            "EnterpriseS" { "2" }
            "WNC" { "3" }
            "Starter" { "4" }
            default { "1" }
        }
        
        Write-Host "Menu option for $targetSku: $menuOption"
        
        # Create a wrapper batch script that:
        # 1. Pipes menu option number to Bedi.cmd for menu selection
        # 2. Pipes "X" to Bedi.cmd for the Choice prompt at the end
        # Note: Bedi.cmd will read Bedi.ini first, but if config doesn't match exactly,
        # it will show menu and wait for input. We pipe the menu option to handle this.
        $lines = @(
          "@echo off",
          "REM Auto-answer menu selection and final Choice prompt",
          "(echo $menuOption & echo X) | Bedi.cmd",
          "exit /b %ERRORLEVEL%"
        )
        $wrapperScript = $lines -join "`r`n"
        
        Set-Content -Path "run-bedi-auto.cmd" -Value $wrapperScript -Encoding ASCII
        
        # Bedi.cmd flow:
        # 1. Calls :_MenuTarget which reads Bedi.ini if exists
        # 2. Always shows menu (_disp) and waits for input
        # 3. If config matches, it updates Bedi.ini (or skips if already matches) and exits
        # 4. If config doesn't match, it updates Bedi.ini and exits
        # 5. After menu, it continues with build process
        # 6. At the end, shows Choice prompt - we pipe "X" to exit
        
        Write-Host "Executing Bedi.cmd with auto-answered prompts..."
        Write-Host "Note: Menu option '$menuOption' will be auto-selected, and 'X' will be chosen at the end"
        $process = Start-Process -FilePath "run-bedi-auto.cmd" -WorkingDirectory $PWD -Wait -NoNewWindow -PassThru -RedirectStandardOutput "bedi_output.txt" -RedirectStandardError "bedi_error.txt"
        
        # Check if Bedi exited because it updated config (exit code 0 but menu was shown)
        # If exit code is 0 but we're still here, Bedi may have updated config and exited
        # In that case, Bedi.ini should now be correct and we can run again
        
        if ($process.ExitCode -eq 0) {
            # Check if Bedi actually completed build or just updated config
            if (Test-Path "bedi_output.txt") {
                $output = Get-Content "bedi_output.txt" -Raw
                if ($output -match "successfully constructed" -or $output -match "FINISH") {
                    Write-Host "Bedi.cmd completed successfully"
                } else {
                    Write-Host "Bedi.cmd may have updated config and exited. Checking..."
                    # Run Bedi again - it should now use the updated config
                    Write-Host "Running Bedi.cmd again with updated config..."
                    $process2 = Start-Process -FilePath "run-bedi-auto.cmd" -WorkingDirectory $PWD -Wait -NoNewWindow -PassThru -RedirectStandardOutput "bedi_output2.txt" -RedirectStandardError "bedi_error2.txt"
                    if ($process2.ExitCode -ne 0) {
                        Write-Warning "Second Bedi.cmd run exited with code: $($process2.ExitCode)"
                        if (Test-Path "bedi_output2.txt") {
                            Write-Host "=== Bedi Output (Run 2) ==="
                            Get-Content "bedi_output2.txt" -Tail 50
                        }
                        exit $process2.ExitCode
                    }
                }
            }
        } else {
            Write-Warning "Bedi.cmd exited with code: $($process.ExitCode)"
            if (Test-Path "bedi_output.txt") {
                Write-Host "=== Bedi Output ==="
                Get-Content "bedi_output.txt" -Tail 50
            }
            if (Test-Path "bedi_error.txt") {
                Write-Host "=== Bedi Errors ==="
                Get-Content "bedi_error.txt" -Tail 50
            }
            exit $process.ExitCode
        }
        
    - name: Check build output
      shell: pwsh
      run: |
        Write-Host "Checking for build output..."
        
        # Read detected build number
        if (Test-Path "detected_build_number.txt") {
          $buildNumber = Get-Content "detected_build_number.txt" -Raw
          $buildNumber = $buildNumber.Trim()
        } else {
          $buildNumber = "22621"
        }
        
        # Look for output WIM files
        $wimFiles = Get-ChildItem -Path "." -Filter "install.wim" -ErrorAction SilentlyContinue
        if ($wimFiles) {
          Write-Host "Build output files found:"
          foreach ($file in $wimFiles) {
            Write-Host "  - $($file.Name) ($([math]::Round($file.Length / 1GB, 2)) GB)"
          }
        } else {
          Write-Warning "No output WIM files found"
          exit 1
        }
        
    - name: Create ISO from built WIM
      shell: pwsh
      run: |
        Write-Host "Creating ISO from built install.wim..."
        
        $wimPath = "$PWD\install.wim"
        $isoMountPath = "$PWD\iso_mount"
        $isoOutputName = "${{ github.event.inputs.iso_output_name }}"
        if ([string]::IsNullOrWhiteSpace($isoOutputName)) {
          $isoOutputName = "Windows-EnterpriseG"
        }
        $isoOutputPath = "$PWD\$isoOutputName.iso"
        
        if (-not (Test-Path $wimPath)) {
          Write-Error "install.wim not found after build"
          exit 1
        }
        
        if (-not (Test-Path $isoMountPath)) {
          Write-Error "ISO structure not found. Cannot recreate ISO."
          exit 1
        }
        
        # Copy the built install.wim back to sources folder
        Write-Host "Copying built install.wim to ISO structure..."
        $sourcesPath = "$isoMountPath\sources"
        if (-not (Test-Path $sourcesPath)) {
          New-Item -ItemType Directory -Path $sourcesPath -Force | Out-Null
        }
        Copy-Item -Path $wimPath -Destination "$sourcesPath\install.wim" -Force
        
        # Create ISO using oscdimg (Windows ADK tool) or mkisofs
        Write-Host "Creating ISO..."
        
        # Get oscdimg path from environment variable or check common locations
        $oscdimgPath = $env:oscdimg_path
        
        if ([string]::IsNullOrWhiteSpace($oscdimgPath)) {
          # Check common locations as fallback
          $oscdimgPaths = @(
            "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",
            "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",
            "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\x86\Oscdimg\oscdimg.exe"
          )
          
          foreach ($path in $oscdimgPaths) {
            if (Test-Path $path) {
              $oscdimgPath = $path
              break
            }
          }
        }
        
        if (-not [string]::IsNullOrWhiteSpace($oscdimgPath) -and (Test-Path $oscdimgPath)) {
          Write-Host "Using oscdimg from Windows ADK..."
          # oscdimg parameters (optimized):
          # -m: maximum file name length (ISO9660)
          # -o: optimize storage (remove duplicate files)
          # -u2: UDF file system
          # -udfver102: UDF version 1.02
          # -h: hide boot files
          # -l: volume label
          # -n: disable long file names (faster)
          # -bootdata: boot sector configuration
          
          # Check if boot files exist
          $bootEtfs = "$isoMountPath\boot\etfsboot.com"
          $bootEfi = "$isoMountPath\efi\Microsoft\boot\efisys.bin"
          
          if ((Test-Path $bootEtfs) -and (Test-Path $bootEfi)) {
            $bootData = "2#p0,e,b`"$bootEtfs`"#pEF,e,b`"$bootEfi`""
            Write-Host "Creating ISO with boot data..."
            & $oscdimgPath -m -o -u2 -udfver102 -h -l "Windows" -bootdata:$bootData $isoMountPath $isoOutputPath 2>&1 | Out-String
          } else {
            Write-Host "Boot files not found, creating ISO without boot data..."
            & $oscdimgPath -m -o -u2 -udfver102 -h -l "Windows" $isoMountPath $isoOutputPath 2>&1 | Out-String
          }
          
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "oscdimg exited with code $LASTEXITCODE. ISO may not be bootable."
          }
        } else {
          Write-Host "oscdimg not found. Installing mkisofs alternative..."
          # Try using 7z to create ISO (if available)
          # Or use PowerShell to create ISO using .NET (limited support)
          
          # Alternative: Use 7z if available
          $7zPath = "$PWD\Files\7z.exe"
          if (Test-Path $7zPath) {
            Write-Host "Using 7z to create ISO archive..."
            # Note: 7z creates .7z archives, not proper ISO files
            # For proper ISO, we need oscdimg or mkisofs
            Write-Warning "7z cannot create proper ISO files. Creating archive instead."
            & $7zPath a -tzip "$isoOutputPath.zip" "$isoMountPath\*"
            Write-Host "Created archive: $isoOutputPath.zip"
            Write-Host "Note: For proper ISO, install Windows ADK or use mkisofs"
          } else {
            Write-Warning "Cannot create ISO without oscdimg or mkisofs"
            Write-Host "Saving ISO structure as archive instead..."
            Compress-Archive -Path "$isoMountPath\*" -DestinationPath "$isoOutputPath.zip" -Force
            Write-Host "Created archive: $isoOutputPath.zip"
            Write-Host "You can recreate ISO manually using oscdimg or mkisofs"
          }
        }
        
        # Verify ISO was created
        if (Test-Path $isoOutputPath) {
          $isoSize = (Get-Item $isoOutputPath).Length / 1GB
          Write-Host "ISO created successfully: $isoOutputPath"
          Write-Host "ISO size: $([math]::Round($isoSize, 2)) GB"
        } elseif (Test-Path "$isoOutputPath.zip") {
          Write-Host "Archive created: $isoOutputPath.zip (use this to recreate ISO)"
        } else {
          Write-Warning "ISO creation may have failed. Check logs above."
        }
        
    - name: Upload build artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: enterpriseg-build
        path: |
          *.iso
          *.zip
          *.wim
          *.log
          Bedi.ini
          bedi_output.txt
          bedi_error.txt
        retention-days: 7
        if-no-files-found: warn
        
    - name: Cleanup temporary files
      if: always()
      shell: pwsh
      run: |
        Write-Host "Cleaning up temporary files..."
        # Clean up mount directories and temporary files
        Get-ChildItem -Path "." -Directory -Filter "mnt*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "log*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "lp*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "sdir*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "sxs*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "iso_mount" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Filter "source.iso" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Filter "run-bedi-auto.cmd" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Filter "source_install.wim" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
        Write-Host "Cleanup completed"

