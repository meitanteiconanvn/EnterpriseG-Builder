name: Build EnterpriseG Edition

on:
  workflow_dispatch:
    inputs:
      target_sku:
        description: 'Target SKU'
        required: true
        default: 'EnterpriseG'
        type: choice
        options:
          - 'EnterpriseG'
          - 'EnterpriseS'
          - 'WNC'
          - 'Starter'
      iso_url:
        description: 'Windows ISO URL'
        required: true
        type: string
      iso_output_name:
        description: 'Output filename'
        required: false
        default: 'Windows-EnterpriseG'
        type: string
      wim_index:
        description: 'WIM Index (empty=auto)'
        required: false
        default: ''
        type: string
      msedge:
        description: 'Edge'
        required: false
        default: 'With'
        type: choice
        options:
          - 'With'
          - 'Without'
      defender:
        description: 'Defender'
        required: false
        default: 'With'
        type: choice
        options:
          - 'With'
          - 'Without'
      winre:
        description: 'WinRE'
        required: false
        default: 'With'
        type: choice
        options:
          - 'With'
          - 'Without'
  push:
    branches:
      - master
      - main
  pull_request:
    branches:
      - master
      - main

jobs:
  build:
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Download Windows ISO
      shell: pwsh
      run: |
        Write-Host "Downloading Windows ISO..."
        $isoUrl = "${{ github.event.inputs.iso_url || env.ISO_URL }}"
        if (-not $isoUrl) {
          Write-Error "ISO URL is required. Please provide it via workflow input or environment variable."
          exit 1
        }
        
        $isoPath = "$PWD\source.iso"
        
        Write-Host "Downloading ISO from: $isoUrl"
        Write-Host "Saving to: $isoPath"
        
        try {
          # Optimize download with resume support and better error handling
          $ProgressPreference = 'SilentlyContinue'
          
          # Use BITS (Background Intelligent Transfer Service) for better resume support
          # Check if file exists and resume download
          if (Test-Path $isoPath) {
            Write-Host "Existing file found. Checking if resume is needed..."
            $existingSize = (Get-Item $isoPath).Length
            
            # Try to get file size from server
            try {
              $request = [System.Net.HttpWebRequest]::Create($isoUrl)
              $request.Method = "HEAD"
              $response = $request.GetResponse()
              $contentLength = $response.ContentLength
              $response.Close()
              
              if ($existingSize -lt $contentLength -and $contentLength -gt 0) {
                Write-Host "Resuming download from $existingSize bytes..."
                $request = [System.Net.HttpWebRequest]::Create($isoUrl)
                $request.AddRange($existingSize)
                $response = $request.GetResponse()
                $stream = $response.GetResponseStream()
                $fileStream = [System.IO.File]::OpenWrite($isoPath)
                $fileStream.Seek($existingSize, [System.IO.SeekOrigin]::Begin) | Out-Null
                $buffer = New-Object byte[] 1MB
                $bytesRead = 0
                do {
                  $bytesRead = $stream.Read($buffer, 0, $buffer.Length)
                  $fileStream.Write($buffer, 0, $bytesRead)
                } while ($bytesRead -gt 0)
                $fileStream.Close()
                $stream.Close()
                $response.Close()
                Write-Host "Resume download completed"
              } else {
                Write-Host "File already complete or cannot resume. Starting fresh download..."
                Remove-Item $isoPath -Force
                Invoke-WebRequest -Uri $isoUrl -OutFile $isoPath -UseBasicParsing -TimeoutSec 3600 -MaximumRetryCount 3
              }
            } catch {
              Write-Host "Resume not supported, downloading fresh..."
              Remove-Item $isoPath -Force
              Invoke-WebRequest -Uri $isoUrl -OutFile $isoPath -UseBasicParsing -TimeoutSec 3600 -MaximumRetryCount 3
            }
          } else {
            # Fresh download with optimized settings
            Invoke-WebRequest -Uri $isoUrl -OutFile $isoPath -UseBasicParsing -TimeoutSec 3600 -MaximumRetryCount 3
          }
          
          $isoSize = (Get-Item $isoPath).Length / 1GB
          Write-Host "ISO download completed. File size: $([math]::Round($isoSize, 2)) GB"
        } catch {
          Write-Error "Failed to download ISO: $_"
          exit 1
        }
        
        if (-not (Test-Path $isoPath)) {
          Write-Error "ISO was not downloaded successfully"
          exit 1
        }
      env:
        ISO_URL: ${{ github.event.inputs.iso_url }}
        
    - name: Setup ISO creation tools
      shell: pwsh
      run: |
        Write-Host "Setting up ISO creation tools..."
        
        # Check multiple common locations for oscdimg
        $oscdimgPaths = @(
          "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",
          "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",
          "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\x86\Oscdimg\oscdimg.exe"
        )
        
        $oscdimgFound = $false
        $oscdimgPath = $null
        
        foreach ($path in $oscdimgPaths) {
          if (Test-Path $path) {
            $oscdimgPath = $path
            $oscdimgFound = $true
            Write-Host "Found oscdimg at: $path"
            break
          }
        }
        
        if (-not $oscdimgFound) {
          Write-Host "oscdimg not found. Attempting to install Windows ADK Deployment Tools..."
          
          # Try Chocolatey first (fastest method)
          $chocoAvailable = Get-Command choco -ErrorAction SilentlyContinue
          
          if ($chocoAvailable) {
            Write-Host "Using Chocolatey to install Windows ADK Deployment Tools..."
            try {
              # Install with verbose output
              $chocoOutput = choco install windows-adk-deployment-tools -y --no-progress 2>&1 | Out-String
              Write-Host "Chocolatey output: $chocoOutput"
              
              # Wait longer for installation to complete
              Write-Host "Waiting for installation to complete..."
              Start-Sleep -Seconds 30
              
              # Refresh environment variables (they might have changed)
              $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
              
              # Check again with expanded paths
              $expandedPaths = @()
              foreach ($path in $oscdimgPaths) {
                $expandedPaths += $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($path)
              }
              
              foreach ($path in $expandedPaths) {
                if (Test-Path $path) {
                  $oscdimgPath = $path
                  $oscdimgFound = $true
                  Write-Host "oscdimg installed via Chocolatey at: $path"
                  break
                }
              }
              
              # Also check Program Files directly
              if (-not $oscdimgFound) {
                $adkBasePaths = @(
                  "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit",
                  "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit"
                )
                
                foreach ($adkBase in $adkBasePaths) {
                  if (Test-Path $adkBase) {
                    Write-Host "Found Windows ADK at: $adkBase"
                    # Search recursively for oscdimg.exe
                    $foundOscdimg = Get-ChildItem -Path $adkBase -Filter "oscdimg.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                    if ($foundOscdimg) {
                      $oscdimgPath = $foundOscdimg.FullName
                      $oscdimgFound = $true
                      Write-Host "Found oscdimg at: $oscdimgPath"
                      break
                    }
                  }
                }
              }
            } catch {
              Write-Warning "Chocolatey installation failed: $_"
            }
          }
          
          # If Chocolatey failed, try downloading Windows ADK installer and installing oscdimg component
          if (-not $oscdimgFound) {
            Write-Host "Chocolatey method failed or not available. Trying Windows ADK installer download..."
            
            # Use the correct Windows ADK download link
            $adkUrl = "https://go.microsoft.com/fwlink/?linkid=2289980"
            $adkInstaller = "$PWD\adksetup.exe"
            
            try {
              Write-Host "Downloading Windows ADK installer..."
              $ProgressPreference = 'SilentlyContinue'
              
              # Try using WebClient first (handles redirects better)
              $client = New-Object System.Net.WebClient
              $client.DownloadFile($adkUrl, $adkInstaller)
              $client.Dispose()
              
              $fileSize = (Get-Item $adkInstaller).Length / 1MB
              Write-Host "Downloaded installer size: $([math]::Round($fileSize, 2)) MB"
              
              # Check if download is actually an installer (should be > 1 MB)
              if ($fileSize -lt 1) {
                Write-Warning "Downloaded file seems too small ($fileSize MB), might be a redirect page."
                Remove-Item $adkInstaller -Force -ErrorAction SilentlyContinue
                throw "Downloaded file is too small"
              }
              
              Write-Host "Installing Windows ADK (download-only mode, then installing oscdimg component)..."
              
              # Step 1: Download ADK components to a folder (don't install yet)
              # /layout: download only
              # /features: specify which features to download (we only need Deployment Tools)
              # /quiet: silent mode
              # /norestart: don't restart
              $downloadFolder = "$PWD\adk_download"
              New-Item -ItemType Directory -Path $downloadFolder -Force | Out-Null
              
              # Try with /features parameter first (more specific)
              $downloadArgs = "/layout `"$downloadFolder`" /features OptionId.DeploymentTools /quiet /norestart"
              Write-Host "Running: $adkInstaller $downloadArgs"
              
              $process = Start-Process -FilePath $adkInstaller -ArgumentList $downloadArgs -Wait -PassThru -NoNewWindow
              
              Write-Host "ADK download process exited with code: $($process.ExitCode)"
              
              # If feature-specific download failed, try without features parameter
              if ($process.ExitCode -ne 0 -and $process.ExitCode -ne 3010) {
                Write-Host "Feature-specific download failed. Trying without features parameter..."
                $downloadArgs = "/layout `"$downloadFolder`" /quiet /norestart"
                $process = Start-Process -FilePath $adkInstaller -ArgumentList $downloadArgs -Wait -PassThru -NoNewWindow
                Write-Host "ADK download process (retry) exited with code: $($process.ExitCode)"
              }
              
              if ($process.ExitCode -eq 0 -or $process.ExitCode -eq 3010) {
                Write-Host "ADK components downloaded. Looking for oscdimg MSI installer..."
                
                # Look for oscdimg MSI installer in the downloaded folder
                $oscImgMsiPaths = @(
                  "$downloadFolder\Windows Kits\10\ADK\Installers\Oscdimg (DesktopEditions)-x86_en-us.msi",
                  "$downloadFolder\Windows Kits\10\ADK\Installers\Oscdimg (DesktopEditions)-amd64_en-us.msi",
                  "$downloadFolder\Windows Kits\10\ADK\Installers\Oscdimg*.msi"
                )
                
                $oscImgMsi = $null
                foreach ($msiPath in $oscImgMsiPaths) {
                  $foundMsi = Get-ChildItem -Path $msiPath -ErrorAction SilentlyContinue | Select-Object -First 1
                  if ($foundMsi) {
                    $oscImgMsi = $foundMsi.FullName
                    Write-Host "Found oscdimg MSI: $oscImgMsi"
                    break
                  }
                }
                
                # Also search recursively
                if (-not $oscImgMsi) {
                  $foundMsi = Get-ChildItem -Path $downloadFolder -Filter "*Oscdimg*.msi" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                  if ($foundMsi) {
                    $oscImgMsi = $foundMsi.FullName
                    Write-Host "Found oscdimg MSI (recursive search): $oscImgMsi"
                  }
                }
                
                if ($oscImgMsi -and (Test-Path $oscImgMsi)) {
                  Write-Host "Installing oscdimg component from MSI..."
                  # Install MSI silently with elevation if needed
                  # /i: install
                  # /quiet: silent installation
                  # /norestart: don't restart
                  # /l*v: verbose logging
                  $msiLog = "$PWD\oscdimg_msi_install.log"
                  $msiArgs = "/i `"$oscImgMsi`" /quiet /norestart /l*v `"$msiLog`""
                  Write-Host "Running: msiexec.exe $msiArgs"
                  
                  $msiProcess = Start-Process -FilePath "msiexec.exe" -ArgumentList $msiArgs -Wait -PassThru -NoNewWindow -Verb RunAs -ErrorAction SilentlyContinue
                  
                  # If RunAs failed, try without elevation (GitHub Actions runners usually have admin)
                  if (-not $msiProcess) {
                    Write-Host "RunAs failed, trying without elevation..."
                    $msiProcess = Start-Process -FilePath "msiexec.exe" -ArgumentList $msiArgs -Wait -PassThru -NoNewWindow
                  }
                  
                  Write-Host "oscdimg MSI installation exited with code: $($msiProcess.ExitCode)"
                  
                  # Check MSI log for details
                  if (Test-Path $msiLog) {
                    Write-Host "MSI installation log (last 20 lines):"
                    Get-Content $msiLog -Tail 20 | ForEach-Object { Write-Host $_ }
                  }
                  
                  if ($msiProcess.ExitCode -eq 0 -or $msiProcess.ExitCode -eq 3010) {
                    Write-Host "Waiting for oscdimg to be available..."
                    Start-Sleep -Seconds 10
                    
                    # Check for oscdimg after installation
                    foreach ($path in $oscdimgPaths) {
                      if (Test-Path $path) {
                        $oscdimgPath = $path
                        $oscdimgFound = $true
                        Write-Host "oscdimg now available at: $path"
                        break
                      }
                    }
                    
                    # If still not found, search recursively
                    if (-not $oscdimgFound) {
                      $adkBasePaths = @(
                        "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit",
                        "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit"
                      )
                      
                      foreach ($adkBase in $adkBasePaths) {
                        if (Test-Path $adkBase) {
                          Write-Host "Searching for oscdimg.exe in: $adkBase"
                          $foundOscdimg = Get-ChildItem -Path $adkBase -Filter "oscdimg.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                          if ($foundOscdimg) {
                            $oscdimgPath = $foundOscdimg.FullName
                            $oscdimgFound = $true
                            Write-Host "Found oscdimg at: $oscdimgPath"
                            break
                          }
                        }
                      }
                    }
                  }
                } else {
                  Write-Warning "Could not find oscdimg MSI installer in downloaded ADK folder"
                }
                
                # Clean up download folder
                Remove-Item -Path $downloadFolder -Recurse -Force -ErrorAction SilentlyContinue
              } else {
                Write-Warning "ADK download process exited with code: $($process.ExitCode)"
              }
              
              # Clean up installer
              Remove-Item $adkInstaller -Force -ErrorAction SilentlyContinue
            } catch {
              Write-Warning "Failed to download/install Windows ADK: $_"
              Write-Host "Error details: $($_.Exception.Message)"
              Write-Host "Will use WSL mkisofs as fallback for ISO creation if oscdimg is not found."
            }
          }
        }
        
        # Save oscdimg path to environment variable for later steps
        if ($oscdimgFound) {
          Write-Host "oscdimg_path=$oscdimgPath" | Out-File -FilePath "$env:GITHUB_ENV" -Encoding utf8 -Append
        } else {
          Write-Host "oscdimg_path=" | Out-File -FilePath "$env:GITHUB_ENV" -Encoding utf8 -Append
        }
        
    - name: Extract install.wim from ISO
      shell: pwsh
      run: |
        Write-Host "Extracting install.wim from ISO..."
        
        $isoPath = "$PWD\source.iso"
        $mountPath = "$PWD\iso_mount"
        $sourceWimPath = "$PWD\source_install.wim"
        $wimPath = "$PWD\install.wim"
        $wimIndex = "${{ github.event.inputs.wim_index }}"
        
        # Mount ISO
        Write-Host "Mounting ISO..."
        $mountResult = Mount-DiskImage -ImagePath $isoPath -StorageType ISO -PassThru
        $driveLetter = ($mountResult | Get-Volume).DriveLetter
        
        if (-not $driveLetter) {
          Write-Error "Failed to mount ISO"
          exit 1
        }
        
        Write-Host "ISO mounted to drive: $driveLetter`:"
        
        # Extract install.wim from sources folder
        $sourceWim = "${driveLetter}:\sources\install.wim"
        
        if (-not (Test-Path $sourceWim)) {
          Write-Error "install.wim not found in ISO sources folder"
          Dismount-DiskImage -ImagePath $isoPath
          exit 1
        }
        
        Write-Host "Copying install.wim from ISO..."
        Copy-Item -Path $sourceWim -Destination $sourceWimPath -Force
        
        # Also copy ISO structure for later ISO recreation
        # Optimize robocopy with multi-threading and better performance
        Write-Host "Copying ISO structure..."
        New-Item -ItemType Directory -Path $mountPath -Force | Out-Null
        # Use /MT for multi-threaded copy (8 threads), /NP to disable progress, /NDL/NJH/NJS for minimal logging
        robocopy "${driveLetter}:\" $mountPath /E /XD sources /MT:8 /NP /NDL /NJH /NJS /R:3 /W:5 | Out-Null
        $robocopyExit = $LASTEXITCODE
        # Robocopy returns 0-7 for success, 8+ for errors
        if ($robocopyExit -ge 8) {
          Write-Warning "Robocopy exited with code $robocopyExit. Some files may not have been copied."
        }
        
        # Unmount ISO
        Write-Host "Unmounting ISO..."
        Dismount-DiskImage -ImagePath $isoPath
        
        # Delete source ISO immediately to save space and improve performance
        Write-Host "Deleting source ISO to save disk space..."
        Remove-Item -Path $isoPath -Force -ErrorAction SilentlyContinue
        
        # Verify source install.wim exists
        if (-not (Test-Path $sourceWimPath)) {
          Write-Error "install.wim extraction failed"
          exit 1
        }
        
        $wimSize = (Get-Item $sourceWimPath).Length / 1GB
        Write-Host "install.wim extracted successfully. Size: $([math]::Round($wimSize, 2)) GB"
        
        # Get WIM info to find Professional edition index and build number
        Write-Host "Analyzing WIM file to find Professional edition and build number..."
        $wimlibPath = "$PWD\Files\wimlib-imagex.exe"
        
        $detectedBuildNumber = $null
        
        if (-not (Test-Path $wimlibPath)) {
          Write-Warning "wimlib-imagex.exe not found, using full install.wim"
          Copy-Item -Path $sourceWimPath -Destination $wimPath -Force
        } else {
          # Get WIM info
          $wimInfo = & $wimlibPath info $sourceWimPath 2>&1 | Out-String
          
          Write-Host "WIM Info:"
          Write-Host $wimInfo
          
          # Extract build number from WIM info
          # Format: Version: 10.0.22621.1 or similar
          $lines = $wimInfo -split "`n"
          $currentIndex = 0
          $proIndex = $null
          $proIndexExact = $null  # Exact match for "Edition ID: Professional"
          
          foreach ($line in $lines) {
            # Detect build number from version string
            if ($line -match "Version:\s+10\.0\.(\d+)\.(\d+)") {
              $buildNum = $matches[1]
              if (-not $detectedBuildNumber) {
                $detectedBuildNumber = $buildNum
                Write-Host "Detected Windows Build Number: $detectedBuildNumber"
              }
            }
            
            # Find Professional edition index - prioritize exact match
            if ($line -match "Index:\s+(\d+)") {
              $currentIndex = [int]$matches[1]
            }
            
            # First, look for exact match "Edition ID: Professional" (not ProfessionalN, ProfessionalEducation, etc.)
            if ($line -match "Edition ID:\s+Professional$" -or $line -match "Edition ID:\s+Professional\s*$") {
              $proIndexExact = $currentIndex
              Write-Host "Found exact Professional edition at index: $proIndexExact"
            }
            
            # Fallback: if no exact match, use first Professional variant
            if (-not $proIndexExact -and ($line -match "Edition ID:\s+Professional" -or $line -match "Name:\s+.*Professional")) {
              if (-not $proIndex) {
                $proIndex = $currentIndex
                Write-Host "Found Professional variant at index: $proIndex"
              }
            }
          }
          
          # Use exact match if found, otherwise use first variant found
          if ($proIndexExact) {
            $proIndex = $proIndexExact
            Write-Host "Using exact Professional edition (index $proIndex)"
          } elseif ($proIndex) {
            Write-Host "Using Professional variant (index $proIndex)"
          }
          
          # Save build number to file for later steps
          if ($detectedBuildNumber) {
            Set-Content -Path "detected_build_number.txt" -Value $detectedBuildNumber
            Write-Host "Build number saved to detected_build_number.txt"
          }
          
          # Find Professional edition index
          if ([string]::IsNullOrWhiteSpace($wimIndex)) {
            if (-not $proIndex) {
              Write-Warning "Could not auto-detect Professional edition. Trying index 1..."
              $proIndex = 1
            }
          } else {
            $proIndex = [int]$wimIndex
            Write-Host "Using specified WIM index: $proIndex"
          }
          
          Write-Host "Extracting Professional edition (index $proIndex) from WIM..."
          
          # Extract only Professional edition to install.wim
          & $wimlibPath export $sourceWimPath $proIndex $wimPath --compress=none
          
          if (-not (Test-Path $wimPath)) {
            Write-Error "Failed to extract Professional edition from WIM"
            exit 1
          }
          
          $extractedSize = (Get-Item $wimPath).Length / 1GB
          Write-Host "Professional edition extracted successfully. Size: $([math]::Round($extractedSize, 2)) GB"
          
          # Clean up source WIM
          Remove-Item -Path $sourceWimPath -Force -ErrorAction SilentlyContinue
        }
        
        if (-not $detectedBuildNumber) {
          Write-Warning "Could not auto-detect build number from WIM. Using default 22621."
          $detectedBuildNumber = "22621"
          Set-Content -Path "detected_build_number.txt" -Value $detectedBuildNumber
        }
        
    - name: Configure Bedi.ini
      shell: pwsh
      run: |
        # Read detected build number from previous step
        if (Test-Path "detected_build_number.txt") {
          $buildNumber = Get-Content "detected_build_number.txt" -Raw
          $buildNumber = $buildNumber.Trim()
          Write-Host "Using detected build number: $buildNumber"
        } else {
          Write-Warning "Build number file not found. Using default 22621."
          $buildNumber = "22621"
        }
        
        $targetSku = "${{ github.event.inputs.target_sku }}"
        $msedge = "${{ github.event.inputs.msedge }}"
        $defender = "${{ github.event.inputs.defender }}"
        $winre = "${{ github.event.inputs.winre }}"
        
        # Set defaults if not provided (for push/PR events)
        if ([string]::IsNullOrWhiteSpace($targetSku)) { $targetSku = "EnterpriseG" }
        if ([string]::IsNullOrWhiteSpace($msedge)) { $msedge = "With" }
        if ([string]::IsNullOrWhiteSpace($defender)) { $defender = "With" }
        if ([string]::IsNullOrWhiteSpace($winre)) { $winre = "With" }
        
        $configLines = @(
          ";#Bedi v7.44 Configurations",
          "_sourSKU=Professional",
          "_targSKU=$targetSku",
          "_store=With",
          "_defender=$defender",
          "_msedge=$msedge",
          "_helospeech=With",
          "_winre=$winre",
          "_wifirtl=With"
        )
        $config = $configLines -join "`n"
        
        Set-Content -Path "Bedi.ini" -Value $config
        Write-Host "Configuration saved to Bedi.ini"
        Get-Content Bedi.ini
        
    - name: Verify required files
      shell: pwsh
      run: |
        Write-Host "Verifying required files..."
        
        # Check install.wim
        if (-not (Test-Path "install.wim")) {
          Write-Error "install.wim not found in root directory"
          exit 1
        }
        
        # Check required tools
        $requiredFiles = @(
          "Files\wimlib-imagex.exe",
          "Files\7z.exe",
          "Files\NSudo.exe",
          "Files\expand.exe",
          "Files\expand_new.exe",
          "Files\7z.dll",
          "Files\libwim-15.dll",
          "Files\ModLCU.cmd",
          "Files\msdelta.dll",
          "Files\PSFExtractor.exe",
          "Files\upmod.cmd"
        )
        
        foreach ($file in $requiredFiles) {
          if (-not (Test-Path $file)) {
            Write-Error "Required file not found: $file"
            exit 1
          }
        }
        
        Write-Host "All required files verified"
        
    - name: Run EnterpriseG Build
      shell: pwsh
      run: |
        Write-Host "Running EnterpriseG build process..."
        
        # Read detected build number from previous step
        if (Test-Path "detected_build_number.txt") {
          $buildNumber = Get-Content "detected_build_number.txt" -Raw
          $buildNumber = $buildNumber.Trim()
          Write-Host "Build Number: $buildNumber"
        } else {
          Write-Warning "Build number not detected. Using default."
        }
        
        Write-Host "Target SKU: ${{ github.event.inputs.target_sku }}"
        
        # Bedi.cmd will check Bedi.ini and if config matches, it will skip menu
        # If config doesn't match, it will update Bedi.ini and exit, then we need to run again
        # To ensure it works, we need to determine the correct menu option based on target SKU
        
        $targetSku = "${{ github.event.inputs.target_sku }}"
        $menuOption = switch ($targetSku) {
          "EnterpriseG" { "1" }
          "EnterpriseS" { "2" }
          "WNC" { "3" }
          "Starter" { "4" }
          default { "1" }
        }
        
        # Create a wrapper script to automate Bedi.cmd menu selection
        # Bedi.cmd will check Bedi.ini - if config matches menu selection, it skips menu
        # Since we already created Bedi.ini with correct config, Bedi should skip menu
        
        Write-Host "Verifying Bedi.ini configuration..."
        $configContent = Get-Content "Bedi.ini" -Raw
        if ($configContent -match "_targSKU=$targetSku" -and $configContent -match "_sourSKU=Professional") {
            Write-Host "Bedi.ini configuration is correct, Bedi.cmd should skip menu"
        } else {
            Write-Warning "Bedi.ini configuration may not match. Bedi will update it if needed."
        }
        
        Write-Host "Starting Bedi.cmd in non-interactive mode..."
        Write-Host ""
        
        # Determine menu option based on target SKU
        # Menu options: 1=EnterpriseG, 2=EnterpriseS, 3=WNC, 4=Starter
        $menuOption = switch ($targetSku) {
            "EnterpriseG" { "1" }
            "EnterpriseS" { "2" }
            "WNC" { "3" }
            "Starter" { "4" }
            default { "1" }
        }
        
        Write-Host "Menu option for $targetSku: $menuOption"
        
        # Create a wrapper batch script that:
        # 1. Pipes menu option number to Bedi.cmd for menu selection
        # 2. Pipes "X" to Bedi.cmd for the Choice prompt at the end
        # Note: Bedi.cmd will read Bedi.ini first, but if config doesn't match exactly,
        # it will show menu and wait for input. We pipe the menu option to handle this.
        $lines = @(
          "@echo off",
          "REM Auto-answer menu selection and final Choice prompt",
          "(echo $menuOption & echo X) | Bedi.cmd",
          "exit /b %ERRORLEVEL%"
        )
        $wrapperScript = $lines -join "`r`n"
        
        Set-Content -Path "run-bedi-auto.cmd" -Value $wrapperScript -Encoding ASCII
        
        # Bedi.cmd flow:
        # 1. Calls :_MenuTarget which reads Bedi.ini if exists
        # 2. Always shows menu (_disp) and waits for input
        # 3. If config matches, it updates Bedi.ini (or skips if already matches) and exits
        # 4. If config doesn't match, it updates Bedi.ini and exits
        # 5. After menu, it continues with build process
        # 6. At the end, shows Choice prompt - we pipe "X" to exit
        
        Write-Host "Executing Bedi.cmd with auto-answered prompts..."
        Write-Host "Note: Menu option '$menuOption' will be auto-selected, and 'X' will be chosen at the end"
        $process = Start-Process -FilePath "run-bedi-auto.cmd" -WorkingDirectory $PWD -Wait -NoNewWindow -PassThru -RedirectStandardOutput "bedi_output.txt" -RedirectStandardError "bedi_error.txt"
        
        # Check if Bedi exited because it updated config (exit code 0 but menu was shown)
        # If exit code is 0 but we're still here, Bedi may have updated config and exited
        # In that case, Bedi.ini should now be correct and we can run again
        
        if ($process.ExitCode -eq 0) {
            # Check if Bedi actually completed build or just updated config
            if (Test-Path "bedi_output.txt") {
                $output = Get-Content "bedi_output.txt" -Raw
                if ($output -match "successfully constructed" -or $output -match "FINISH") {
                    Write-Host "Bedi.cmd completed successfully"
                } else {
                    Write-Host "Bedi.cmd may have updated config and exited. Checking..."
                    # Run Bedi again - it should now use the updated config
                    Write-Host "Running Bedi.cmd again with updated config..."
                    $process2 = Start-Process -FilePath "run-bedi-auto.cmd" -WorkingDirectory $PWD -Wait -NoNewWindow -PassThru -RedirectStandardOutput "bedi_output2.txt" -RedirectStandardError "bedi_error2.txt"
                    if ($process2.ExitCode -ne 0) {
                        Write-Warning "Second Bedi.cmd run exited with code: $($process2.ExitCode)"
                        if (Test-Path "bedi_output2.txt") {
                            Write-Host "=== Bedi Output (Run 2) ==="
                            Get-Content "bedi_output2.txt" -Tail 50
                        }
                        exit $process2.ExitCode
                    }
                }
            }
        } else {
            Write-Warning "Bedi.cmd exited with code: $($process.ExitCode)"
            if (Test-Path "bedi_output.txt") {
                Write-Host "=== Bedi Output ==="
                Get-Content "bedi_output.txt" -Tail 50
            }
            if (Test-Path "bedi_error.txt") {
                Write-Host "=== Bedi Errors ==="
                Get-Content "bedi_error.txt" -Tail 50
            }
            exit $process.ExitCode
        }
        
    - name: Check build output
      shell: pwsh
      run: |
        Write-Host "Checking for build output..."
        
        # Read detected build number
        if (Test-Path "detected_build_number.txt") {
          $buildNumber = Get-Content "detected_build_number.txt" -Raw
          $buildNumber = $buildNumber.Trim()
        } else {
          $buildNumber = "22621"
        }
        
        # Look for output WIM files
        $wimFiles = Get-ChildItem -Path "." -Filter "install.wim" -ErrorAction SilentlyContinue
        if ($wimFiles) {
          Write-Host "Build output files found:"
          foreach ($file in $wimFiles) {
            Write-Host "  - $($file.Name) ($([math]::Round($file.Length / 1GB, 2)) GB)"
          }
        } else {
          Write-Warning "No output WIM files found"
          exit 1
        }
        
    - name: Create ISO from built WIM
      shell: pwsh
      run: |
        Write-Host "Creating ISO from built install.wim..."
        
        $wimPath = "$PWD\install.wim"
        $isoMountPath = "$PWD\iso_mount"
        $isoOutputName = "${{ github.event.inputs.iso_output_name }}"
        if ([string]::IsNullOrWhiteSpace($isoOutputName)) {
          $isoOutputName = "Windows-EnterpriseG"
        }
        $isoOutputPath = "$PWD\$isoOutputName.iso"
        
        if (-not (Test-Path $wimPath)) {
          Write-Error "install.wim not found after build"
          exit 1
        }
        
        if (-not (Test-Path $isoMountPath)) {
          Write-Error "ISO structure not found. Cannot recreate ISO."
          exit 1
        }
        
        # Copy the built install.wim back to sources folder
        Write-Host "Copying built install.wim to ISO structure..."
        $sourcesPath = "$isoMountPath\sources"
        if (-not (Test-Path $sourcesPath)) {
          New-Item -ItemType Directory -Path $sourcesPath -Force | Out-Null
        }
        Copy-Item -Path $wimPath -Destination "$sourcesPath\install.wim" -Force
        
        # Create ISO using oscdimg (Windows ADK tool) or mkisofs
        Write-Host "Creating ISO..."
        
        # Get oscdimg path from environment variable or check common locations
        $oscdimgPath = $env:oscdimg_path
        
        Write-Host "Checking for oscdimg.exe..."
        Write-Host "From environment variable: $oscdimgPath"
        
        if ([string]::IsNullOrWhiteSpace($oscdimgPath) -or -not (Test-Path $oscdimgPath)) {
          Write-Host "oscdimg not found in environment variable. Checking common locations..."
          
          # Check common locations as fallback
          $oscdimgPaths = @(
            "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",
            "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",
            "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\x86\Oscdimg\oscdimg.exe"
          )
          
          foreach ($path in $oscdimgPaths) {
            Write-Host "Checking: $path"
            if (Test-Path $path) {
              $oscdimgPath = $path
              Write-Host "Found oscdimg at: $path"
              break
            }
          }
          
          # If still not found, do recursive search
          if ([string]::IsNullOrWhiteSpace($oscdimgPath)) {
            Write-Host "oscdimg not found in common locations. Searching recursively..."
            
            $adkBasePaths = @(
              "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit",
              "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit"
            )
            
            foreach ($adkBase in $adkBasePaths) {
              if (Test-Path $adkBase) {
                Write-Host "Searching in: $adkBase"
                $foundOscdimg = Get-ChildItem -Path $adkBase -Filter "oscdimg.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($foundOscdimg) {
                  $oscdimgPath = $foundOscdimg.FullName
                  Write-Host "Found oscdimg recursively at: $oscdimgPath"
                  break
                }
              }
            }
          }
        }
        
        if (-not [string]::IsNullOrWhiteSpace($oscdimgPath) -and (Test-Path $oscdimgPath)) {
          Write-Host "Using oscdimg: $oscdimgPath"
          Write-Host "Using oscdimg from Windows ADK..."
          # oscdimg parameters (optimized):
          # -m: maximum file name length (ISO9660)
          # -o: optimize storage (remove duplicate files)
          # -u2: UDF file system
          # -udfver102: UDF version 1.02
          # -h: hide boot files
          # -l: volume label
          # -n: disable long file names (faster)
          # -bootdata: boot sector configuration
          
          # Check if boot files exist
          $bootEtfs = "$isoMountPath\boot\etfsboot.com"
          $bootEfi = "$isoMountPath\efi\Microsoft\boot\efisys.bin"
          
          if ((Test-Path $bootEtfs) -and (Test-Path $bootEfi)) {
            $bootData = "2#p0,e,b`"$bootEtfs`"#pEF,e,b`"$bootEfi`""
            Write-Host "Creating ISO with boot data..."
            & $oscdimgPath -m -o -u2 -udfver102 -h -l "Windows" -bootdata:$bootData $isoMountPath $isoOutputPath 2>&1 | Out-String
          } else {
            Write-Host "Boot files not found, creating ISO without boot data..."
            & $oscdimgPath -m -o -u2 -udfver102 -h -l "Windows" $isoMountPath $isoOutputPath 2>&1 | Out-String
          }
          
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "oscdimg exited with code $LASTEXITCODE. ISO may not be bootable."
          }
        } else {
          Write-Host "oscdimg not found. Trying alternative methods..."
          
          # Try using WSL mkisofs as fallback
          $wslAvailable = Get-Command wsl -ErrorAction SilentlyContinue
          $mkisofsFound = $false
          
          if ($wslAvailable) {
            Write-Host "Attempting to use WSL mkisofs..."
            try {
              # Check if mkisofs exists
              $mkisofsCheck = wsl which mkisofs 2>&1
              if ($mkisofsCheck -match "mkisofs") {
                $mkisofsFound = $true
                Write-Host "mkisofs found in WSL, attempting to create ISO..."
                
                # Convert Windows path to WSL path
                $wslPath = wsl wslpath -a "$isoMountPath" 2>&1
                $wslOutput = wsl wslpath -a "$isoOutputPath" 2>&1
                
                # Create ISO using mkisofs
                # -r: Rock Ridge extensions (for long filenames)
                # -J: Joliet extensions (for Windows compatibility)
                # -o: output file
                # -V: volume label
                $mkisofsCmd = "mkisofs -r -J -o `"$wslOutput`" -V Windows `"$wslPath`""
                $mkisofsResult = wsl bash -c $mkisofsCmd 2>&1
                
                if (Test-Path $isoOutputPath) {
                  $isoSize = (Get-Item $isoOutputPath).Length / 1GB
                  Write-Host "ISO created successfully using mkisofs: $isoOutputPath"
                  Write-Host "ISO size: $([math]::Round($isoSize, 2)) GB"
                } else {
                  Write-Warning "mkisofs command executed but ISO not found: $mkisofsResult"
                  $mkisofsFound = $false
                }
              } else {
                Write-Host "mkisofs not found in WSL, attempting to install..."
                # Try to install genisoimage (provides mkisofs)
                $installResult = wsl sudo apt-get update -qq 2>&1
                $installResult2 = wsl sudo apt-get install -y genisoimage 2>&1
                
                # Check again
                $mkisofsCheck2 = wsl which mkisofs 2>&1
                if ($mkisofsCheck2 -match "mkisofs") {
                  Write-Host "mkisofs installed successfully, creating ISO..."
                  $wslPath = wsl wslpath -a "$isoMountPath" 2>&1
                  $wslOutput = wsl wslpath -a "$isoOutputPath" 2>&1
                  $mkisofsCmd = "mkisofs -r -J -o `"$wslOutput`" -V Windows `"$wslPath`""
                  $mkisofsResult = wsl bash -c $mkisofsCmd 2>&1
                  
                  if (Test-Path $isoOutputPath) {
                    $isoSize = (Get-Item $isoOutputPath).Length / 1GB
                    Write-Host "ISO created successfully using mkisofs: $isoOutputPath"
                    Write-Host "ISO size: $([math]::Round($isoSize, 2)) GB"
                    $mkisofsFound = $true
                  } else {
                    Write-Warning "mkisofs failed: $mkisofsResult"
                    $mkisofsFound = $false
                  }
                } else {
                  Write-Warning "Failed to install mkisofs"
                  $mkisofsFound = $false
                }
              }
            } catch {
              Write-Warning "WSL mkisofs method failed: $_"
              $mkisofsFound = $false
            }
          }
          
          # If mkisofs also failed, fall back to ZIP
          if (-not $mkisofsFound) {
            Write-Host "All ISO creation methods failed. Creating ZIP archive instead..."
            # Use 7z if available
            $7zPath = "$PWD\Files\7z.exe"
            if (Test-Path $7zPath) {
              Write-Host "Using 7z to create archive..."
              & $7zPath a -tzip "$isoOutputPath.zip" "$isoMountPath\*"
              Write-Host "Created archive: $isoOutputPath.zip"
            } else {
              Write-Host "Using PowerShell Compress-Archive..."
              Compress-Archive -Path "$isoMountPath\*" -DestinationPath "$isoOutputPath.zip" -Force
              Write-Host "Created archive: $isoOutputPath.zip"
            }
            Write-Host "Note: For proper ISO, install Windows ADK or use mkisofs"
          }
        }
        
        # Verify ISO was created
        if (Test-Path $isoOutputPath) {
          $isoSize = (Get-Item $isoOutputPath).Length / 1GB
          Write-Host "ISO created successfully: $isoOutputPath"
          Write-Host "ISO size: $([math]::Round($isoSize, 2)) GB"
        } elseif (Test-Path "$isoOutputPath.zip") {
          Write-Host "Archive created: $isoOutputPath.zip (use this to recreate ISO)"
        } else {
          Write-Warning "ISO creation may have failed. Check logs above."
        }
        
    - name: Upload build artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: enterpriseg-build
        path: |
          *.iso
          *.zip
          *.wim
          *.log
          Bedi.ini
          bedi_output.txt
          bedi_error.txt
        retention-days: 7
        if-no-files-found: warn
        
    - name: Cleanup temporary files
      if: always()
      shell: pwsh
      run: |
        Write-Host "Cleaning up temporary files..."
        # Clean up mount directories and temporary files
        Get-ChildItem -Path "." -Directory -Filter "mnt*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "log*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "lp*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "sdir*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "sxs*" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Directory -Filter "iso_mount" -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Filter "source.iso" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Filter "run-bedi-auto.cmd" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
        Get-ChildItem -Path "." -Filter "source_install.wim" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
        Write-Host "Cleanup completed"

